-- PostgreSQL 12.12
drop table if exists contracts, parts, parts_supplies;

CREATE TABLE contracts (
    number INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_code INT GENERATED BY DEFAULT AS IDENTITY NOT NULL CHECK (supplier_code > 0),
    conclusion_date TIMESTAMP
);

CREATE TABLE parts (
    code INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type VARCHAR(3) NOT NULL DEFAULT 'own' CHECK (type IN ('pur', 'own')),
    name VARCHAR(50) NOT NULL,
    measure VARCHAR(8) NOT NULL DEFAULT 'pieces',
    target_price NUMERIC(8,2) NOT NULL CHECK (target_price >= 0.00)
);

CREATE TABLE parts_supplies (
    contract_number INT REFERENCES contracts(number) ON DELETE CASCADE ON UPDATE CASCADE,
    part_code INT REFERENCES parts(code),
    PRIMARY KEY (contract_number, part_code),
    measure VARCHAR(8) NOT NULL DEFAULT 'pieces',
    delivery_start_date DATE NOT NULL CHECK (delivery_start_date > '2000-01-01'),
    delivery_end_date DATE NOT NULL CHECK (delivery_end_date > delivery_start_date),
    delivery_plan INT NOT NULL DEFAULT 0 CHECK (delivery_plan >= 0),
    contract_price NUMERIC(8,2) NOT NULL CHECK (contract_price >= 0.00)
);

---------------------------------------------------------------------------------------------------

truncate contracts, parts, parts_supplies;

INSERT INTO parts (type, name, target_price) VALUES
     ('pur', 'Процессор Intel Core i3 10100F', 5590.00),
     ('pur', 'Материнская плата ASUS ROG MAXIMUS Z690 HERO EVA', 55990.00),
     ('pur', 'Видеокарта DELL NVIDIA Quadro RTX6000', 32099.00),
     ('own', 'Блок питания GIGABYTE GP-AP1200PM', 24000.50),
     ('own', 'Kingston Fury Beast KF556C40BB-32 DDR5', 16000.90);

INSERT INTO contracts (supplier_code, conclusion_date) VALUES
    (354046, current_timestamp),
    (843, current_timestamp),
    (244, current_timestamp),
    (579, current_timestamp),
    (434, NOW());

INSERT INTO parts_supplies (contract_number, part_code, delivery_start_date, delivery_end_date,
                            delivery_plan, contract_price)
VALUES
    (1, 1, '2022-03-21 10:10:01', '2022-09-30 09:37:23', 10000, 5650.50),
    (2, 2, '2022-01-14 03:45:51', '2022-08-23 04:31:01', 1000, 57850.50),
    (3, 3, '2022-05-19 01:10:17', '2024-05-21 09:41:57', 20000, 34070.99),
    (4, 4, '2008-03-10 11:00:07', '2008-09-21 00:24:02', 850, 25010.00),
    (5, 5, '2012-02-12 07:12:31', '2017-08-31 11:00:45', 24000, 17000.50);

---------------------------------------------------------------------------------------------------

-- Task 1
SELECT parts_supplies.contract_number, parts.name, parts_supplies.contract_price,
parts_supplies.delivery_plan FROM parts_supplies
INNER JOIN parts ON parts.code = parts_supplies.part_code
AND parts_supplies.delivery_start_date >= '2021-01-01';

-- Task 2
SELECT parts.code, parts.name, (SUM(parts_supplies.contract_price) * parts_supplies.delivery_plan) AS Total,
    '' AS measure, null AS target_price, '' AS type
    FROM parts INNER JOIN parts_supplies
    ON parts.code = parts_supplies.part_code
    AND EXTRACT(YEAR FROM parts_supplies.delivery_start_date) = EXTRACT(YEAR FROM current_timestamp)
    GROUP BY parts.code, parts_supplies.delivery_plan, parts_supplies.contract_price;

-- Task 3
SELECT contract_number, part_code, parts_supplies.measure, delivery_start_date, delivery_end_date,
    delivery_plan, contract_price FROM parts_supplies
    INNER JOIN parts ON parts.code = parts_supplies.part_code
    AND parts.type = 'pur' AND parts_supplies.delivery_plan > 100;


-- View of three tables in one
CREATE VIEW three_to_one AS
SELECT * FROM parts
NATURAL JOIN parts_supplies
NATURAL JOIN contracts;

---------------------------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS fn_calculate_profit_margin_and_completed_contracts_number,
    fn_calculate_profit_on_completed_contracts,
    fn_cascade_delete, fn_get_number_of_completed_contracts,
    fn_run_task1;

CREATE OR REPLACE FUNCTION fn_get_number_of_completed_contracts(IN user_date date)
    RETURNS BIGINT AS
$body$
BEGIN
    RETURN COUNT(*) FROM parts_supplies
    WHERE parts_supplies.delivery_end_date <= user_date;
END
$body$
    LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fn_calculate_profit_on_completed_contracts(IN user_date date)
    RETURNS NUMERIC AS
$body$
BEGIN
    RETURN SUM((parts_supplies.contract_price - parts.target_price) * delivery_plan)
    FROM parts_supplies, parts WHERE parts_supplies.part_code = parts.code
    AND parts_supplies.delivery_end_date <= user_date;
END
$body$
    LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fn_calculate_profit_margin_and_completed_contracts_number(
    IN user_date DATE
)
    RETURNS TABLE (
                      completed_contracts_number bigint,
                      received_profit numeric
                  ) AS
$body$
BEGIN
    RETURN QUERY
        SELECT fn_get_number_of_completed_contracts(user_date),
               fn_calculate_profit_on_completed_contracts(user_date);
END
$body$
    LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION fn_run_task1(IN user_date DATE)
RETURNS TABLE (
    Номер_договора INT,
    Название_детали VARCHAR,
    Цена NUMERIC,
    План_поставки INT
) AS
$body$
BEGIN
    RETURN QUERY
    SELECT parts_supplies.contract_number, parts.name, parts_supplies.contract_price,
    parts_supplies.delivery_plan FROM parts_supplies
    INNER JOIN parts ON parts.code = parts_supplies.part_code
    AND parts_supplies.delivery_start_date >= user_date;
END
$body$
    LANGUAGE plpgsql;

---------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE pr_set_disount(IN user_contract_number INT, IN discount_amount NUMERIC,
                                           INOUT new_contract_price NUMERIC DEFAULT NULL)
AS
$body$
BEGIN
    UPDATE parts_supplies
    SET contract_price = contract_price - (contract_price / 100) * discount_amount
    WHERE contract_number =  user_contract_number;
    SELECT contract_price FROM parts_supplies
    WHERE contract_number =  user_contract_number INTO new_contract_price;
    COMMIT;
END
$body$
    LANGUAGE plpgsql;

---------------------------------------------------------------------------------------------------

-- TRIGGER delete
CREATE OR REPLACE FUNCTION fn_cascade_delete()
    RETURNS TRIGGER
AS
$body$
BEGIN
    DELETE FROM parts_supplies
    WHERE parts_supplies.code = OLD.code;
    RETURN OLD;
END
$body$
    LANGUAGE plpgsql;


CREATE TRIGGER deletion
    BEFORE DELETE
    ON parts
    FOR EACH ROW
EXECUTE PROCEDURE fn_cascade_delete();
